---
timestamp: 'Thu Oct 16 2025 21:50:58 GMT-0400 (Eastern Daylight Time)'
parent: '[[..\20251016_215058.fe9ba1f8.md]]'
content_id: 0fba1ac675cc46566809739a644e664dd8e848727933d8286dcd69c710f6780c
---

# file: src/ReminderPolicy/ReminderPolicyConcept.ts

```typescript
import { Collection, Db } from "npm:mongodb";
import { Empty, ID } from "@utils/types.ts";
import { freshID } from "@utils/database.ts";

/**
 * concept ReminderPolicy [User, Policy]
 *
 * purpose
 * manage reusable reminder templates that adapt to user behavior and event types
 *
 * principle
 * after selecting a policy for an event type, generates personalized reminders based on learned patterns;
 * users define default policies with timing rules (e.g., 24 hours before, 30 minutes before);
 * system learns from user behavior (early dismissals, snoozes) and adjusts future reminder times;
 * policies are matched to events via tags, with personalization applied during instantiation
 */

// Declare collection prefix, use concept name
const PREFIX = "ReminderPolicy" + ".";

// Generic types of this concept
type User = ID;
type Policy = ID;
type Tag = string;
type ReminderType = "notification" | "email" | "sms";
type DateTime = Date; // Using native Date object for DateTime

/**
 * where Rule has
 *    an offset Number // minutes before event
 *    a type ReminderType // "notification", "email", "sms"
 */
interface Rule {
  offset: number; // minutes before event
  type: ReminderType;
}

/**
 * A reminder generated by the instantiate action.
 */
interface Reminder {
  time: DateTime;
  type: ReminderType;
}

/**
 * a set of Policy with
 * a user User
 * a name String
 * tags Set<Tag>
 * rules Sequence<Rule> // ordered list of reminder rules
 */
interface PolicyDoc {
  _id: Policy;
  user: User;
  name: string;
  tags: Tag[];
  rules: Rule[];
}

/**
 * a set of Personalization with
 * a user User
 * a tag Tag
 * an avgOffset Number // learned average offset in minutes
 * an effectiveness Float // 0.0-1.0 score for personalization effectiveness
 */
interface PersonalizationDoc {
  _id: ID; // Unique ID for this personalization entry (user, tag)
  user: User;
  tag: Tag;
  avgOffset: number; // learned average offset in minutes
  effectiveness: number; // 0.0-1.0 score for personalization effectiveness
}

/**
 * a set of DefaultPolicy with
 * a user User
 * a tag Tag
 * a policy Policy // default policy for this user-tag combination
 */
interface DefaultPolicyDoc {
  _id: ID; // Unique ID for this default policy entry (user, tag)
  user: User;
  tag: Tag;
  policy: Policy; // ID of the default policy
}

export default class ReminderPolicyConcept {
  policies: Collection<PolicyDoc>;
  personalizations: Collection<PersonalizationDoc>;
  defaultPolicies: Collection<DefaultPolicyDoc>;

  constructor(private readonly db: Db) {
    this.policies = this.db.collection(PREFIX + "policies");
    this.personalizations = this.db.collection(PREFIX + "personalizations");
    this.defaultPolicies = this.db.collection(PREFIX + "defaultPolicies");

    // Ensure unique index for default policies per user+tag to prevent duplicates
    this.defaultPolicies.createIndex({ user: 1, tag: 1 }, { unique: true }).catch(console.error);
    // Ensure unique index for personalizations per user+tag
    this.personalizations.createIndex({ user: 1, tag: 1 }, { unique: true }).catch(console.error);
  }

  /**
   * Helper to clamp a number between a min and max value.
   * @param value The number to clamp.
   * @param min The minimum allowed value.
   * @param max The maximum allowed value.
   * @returns The clamped number.
   */
  private clamp(value: number, min: number, max: number): number {
    return Math.max(min, Math.min(value, max));
  }

  /**
   * createPolicy(user: User, name: String, tags: Set<Tag>, rules: Sequence<Rule>): Policy
   *
   * requires name is non-empty, rules is non-empty, all offsets are positive
   * effect creates new policy and sets as default for tags if no default exists
   * note returns the created policy ID
   */
  async createPolicy(
    { user, name, tags, rules }: { user: User; name: string; tags: Set<Tag>; rules: Rule[] },
  ): Promise<Policy | { error: string }> {
    if (!name.trim()) {
      return { error: "Policy name cannot be empty." };
    }
    if (!rules || rules.length === 0) {
      return { error: "Policy must have at least one rule." };
    }
    if (rules.some((r) => r.offset <= 0)) {
      return { error: "All rule offsets must be positive." };
    }
    const tagsArray = Array.from(tags);
    if (tagsArray.some(tag => !tag.trim())) {
      return { error: "Tags cannot be empty strings." };
    }

    const newPolicyId = freshID();
    const newPolicy: PolicyDoc = {
      _id: newPolicyId,
      user,
      name,
      tags: tagsArray,
      rules,
    };

    try {
      await this.policies.insertOne(newPolicy);

      // Set as default for tags if no default exists
      for (const tag of tagsArray) {
        const existingDefault = await this.defaultPolicies.findOne({ user, tag });
        if (!existingDefault) {
          // Use `updateOne` with `upsert: true` to handle potential race conditions
          // where another createPolicy might try to set a default for the same tag simultaneously.
          // Although `findOne` then `insertOne` is typically okay in a single-threaded environment
          // or with appropriate locking, `upsert` is safer for unique constraints.
          await this.defaultPolicies.updateOne(
            { user, tag },
            { $setOnInsert: { _id: freshID(), user, tag, policy: newPolicyId } },
            { upsert: true },
          );
        }
      }

      return newPolicyId;
    } catch (e) {
      console.error("Error creating policy:", e);
      return { error: "Failed to create policy due to a database error." };
    }
  }

  /**
   * selectPolicy(user: User, tags: Set<Tag>): Policy?
   *
   * requires tags is non-empty
   * effect finds policy matching most tags; checks default policies if no exact match
   * note returns best matching policy or none if no policy matches
   * note prioritizes policies with maximum tag overlap
   */
  async selectPolicy(
    { user, tags }: { user: User; tags: Set<Tag> },
  ): Promise<Policy | null | { error: string }> {
    if (!tags || tags.size === 0) {
      return { error: "Tags cannot be empty for policy selection." };
    }
    const queryTags = Array.from(tags);

    try {
      const userPolicies = await this.policies.find({ user }).toArray();

      let bestMatch: Policy | null = null;
      let maxOverlap = -1;

      for (const policy of userPolicies) {
        // Calculate overlap: how many queryTags are present in policy.tags
        const overlap = queryTags.filter((tag) => policy.tags.includes(tag)).length;

        if (overlap > maxOverlap) {
          maxOverlap = overlap;
          bestMatch = policy._id;
        } else if (overlap === maxOverlap && maxOverlap > 0) {
          // Tie-breaking: if multiple policies have the same max overlap,
          // prioritize the one with more total tags (more specific)
          // or simply pick the first one found. For simplicity, pick the first one.
          // (The current loop naturally picks the first one encountered that has maxOverlap).
        }
      }

      if (bestMatch && maxOverlap > 0) {
        return bestMatch; // Found a policy with tag overlap
      }

      // If no tag-matching policy, check for default policies based on any of the input tags
      for (const tag of queryTags) {
        const defaultPolicy = await this.defaultPolicies.findOne({ user, tag });
        if (defaultPolicy) {
          // Ensure the default policy still exists and belongs to the user
          const policyExists = await this.policies.findOne({ _id: defaultPolicy.policy, user });
          if (policyExists) {
            return defaultPolicy.policy;
          } else {
            // Clean up stale default policy mapping if the policy it refers to is gone
            await this.defaultPolicies.deleteOne({ _id: defaultPolicy._id });
          }
        }
      }

      return null; // No matching policy found
    } catch (e) {
      console.error("Error selecting policy:", e);
      return { error: "Failed to select policy due to a database error." };
    }
  }

  /**
   * instantiate(user: User, policy: Policy, eventStart: DateTime): Sequence<Reminder>
   *
   * requires policy exists, policy belongs to user
   * effect generates reminders by applying policy rules with personalization adjustments
   * note blends rule offset with learned offset based on effectiveness score
   * note returns list of reminders with absolute times and types
   */
  async instantiate(
    { user, policy: policyId, eventStart }: { user: User; policy: Policy; eventStart: DateTime },
  ): Promise<Reminder[] | { error: string }> {
    if (!(eventStart instanceof Date) || isNaN(eventStart.getTime())) {
      return { error: "eventStart must be a valid Date object." };
    }

    try {
      const policy = await this.policies.findOne({ _id: policyId, user });
      if (!policy) {
        return { error: "Policy not found or does not belong to the user." };
      }

      const reminders: Reminder[] = [];

      // Determine which tag's personalization to use if policy has multiple tags.
      // For simplicity, we'll use the first tag for which personalization data exists.
      // If no personalization data for any tag, default values are used.
      let personalization: PersonalizationDoc | null = null;
      for (const tag of policy.tags) {
        personalization = await this.personalizations.findOne({ user, tag });
        if (personalization) {
          break; // Found personalization for one of the policy's tags
        }
      }

      const initialEffectiveness = 0.5; // As per notes: "Initial effectiveness is 0.5"

      for (const rule of policy.rules) {
        let adjustedOffset = rule.offset; // Default to rule offset

        if (personalization) {
          const effectiveness = this.clamp(personalization.effectiveness, 0.0, 1.0);
          const learnedOffset = personalization.avgOffset;

          // Formula: adjustedOffset = ruleOffset × (1 - effectiveness) + learnedOffset × effectiveness
          adjustedOffset = rule.offset * (1 - effectiveness) + learnedOffset * effectiveness;
          adjustedOffset = Math.max(1, adjustedOffset); // Ensure offset remains positive (at least 1 minute)
        } else {
          // If no personalization, the notes say "Initial effectiveness is 0.5"
          // This implies a blend even without learned data, but if no learned data,
          // learnedOffset is effectively 0 or same as ruleOffset.
          // The most straightforward interpretation is to just use the rule.offset directly
          // if no personalization record exists.
          // The `notes` section's blending formula is for *when* personalization exists.
          // Let's stick to using the rule.offset directly if `personalization` is null.
        }

        const reminderTime = new Date(eventStart.getTime());
        reminderTime.setMinutes(reminderTime.getMinutes() - adjustedOffset);

        reminders.push({
          time: reminderTime,
          type: rule.type,
        });
      }

      return reminders;
    } catch (e) {
      console.error("Error instantiating reminders:", e);
      return { error: "Failed to instantiate reminders due to an internal error." };
    }
  }

  /**
   * learn(user: User, tag: Tag, actualOffset: Number, wasEffective: Boolean)
   *
   * requires actualOffset is positive
   * effect updates personalization data using exponential moving average
   * note increases effectiveness score if wasEffective, decreases otherwise
   * note creates new personalization entry if none exists for (user, tag)
   */
  async learn(
    { user, tag, actualOffset, wasEffective }: {
      user: User;
      tag: Tag;
      actualOffset: number;
      wasEffective: boolean;
    },
  ): Promise<Empty | { error: string }> {
    if (actualOffset <= 0) {
      return { error: "actualOffset must be positive." };
    }
    if (!tag.trim()) {
      return { error: "Tag cannot be empty." };
    }

    const alpha = 0.3; // Learning rate (alpha = 0.3)
    const effectivenessChange = wasEffective ? 0.1 : -0.1; // Effectiveness adjusts ±0.1

    try {
      const existingPersonalization = await this.personalizations.findOne({ user, tag });

      let newAvgOffset: number;
      let newEffectiveness: number;

      if (!existingPersonalization) {
        // Create new personalization entry
        newAvgOffset = actualOffset;
        // Initial effectiveness is 0.5, then adjusted
        newEffectiveness = this.clamp(0.5 + effectivenessChange, 0.0, 1.0);

        await this.personalizations.insertOne({
          _id: freshID(),
          user,
          tag,
          avgOffset: newAvgOffset,
          effectiveness: newEffectiveness,
        });
      } else {
        // Update existing personalization
        newAvgOffset = (1 - alpha) * existingPersonalization.avgOffset + alpha * actualOffset;
        newEffectiveness = this.clamp(
          existingPersonalization.effectiveness + effectivenessChange,
          0.0,
          1.0,
        );

        await this.personalizations.updateOne(
          { _id: existingPersonalization._id },
          { $set: { avgOffset: newAvgOffset, effectiveness: newEffectiveness } },
        );
      }
      return {};
    } catch (e) {
      console.error("Error learning from user behavior:", e);
      return { error: "Failed to update personalization data due to a database error." };
    }
  }

  /**
   * _getPolicy(policy: Policy): Map<String,Any>
   *
   * requires policy exists
   * effect returns policy data including name, tags, and rules
   * note this is a query method (starts with underscore)
   */
  async _getPolicy(
    { policy: policyId }: { policy: Policy },
  ): Promise<Map<string, unknown> | null> {
    try {
      const policy = await this.policies.findOne({ _id: policyId });
      if (policy) {
        // Convert to Map<String,Any> as specified
        return new Map(Object.entries(policy));
      }
      return null;
    } catch (e) {
      console.error("Error getting policy:", e);
      // In queries, typically return null/empty on error or propagate.
      // For this spec, returning null for "not found" or internal error might be acceptable.
      return null;
    }
  }

  /**
   * _getUserPolicies(user: User): Set<Policy>
   *
   * effect returns all policies for the user
   * note this is a query method (starts with underscore)
   */
  async _getUserPolicies({ user }: { user: User }): Promise<Set<Policy>> {
    try {
      const policies = await this.policies.find({ user }).project({ _id: 1 }).toArray();
      return new Set(policies.map((p) => p._id));
    } catch (e) {
      console.error("Error getting user policies:", e);
      return new Set();
    }
  }

  /**
   * updatePolicy(policy: Policy, name: String?, rules: Sequence<Rule>?)
   *
   * requires policy exists, if rules provided then non-empty
   * effect updates policy name and/or rules
   * note does not affect existing reminders, only future instantiations
   */
  async updatePolicy(
    { policy: policyId, name, rules }: { policy: Policy; name?: string; rules?: Rule[] },
  ): Promise<Empty | { error: string }> {
    if (rules !== undefined) {
      if (!rules || rules.length === 0) {
        return { error: "If rules are provided, they cannot be empty." };
      }
      if (rules.some((r) => r.offset <= 0)) {
        return { error: "All rule offsets must be positive." };
      }
    }
    if (name !== undefined && !name.trim()) {
      return { error: "Policy name cannot be empty if provided." };
    }

    try {
      const updateDoc: { $set: { [key: string]: unknown } } = { $set: {} };
      if (name !== undefined) {
        updateDoc.$set.name = name;
      }
      if (rules !== undefined) {
        updateDoc.$set.rules = rules;
      }

      if (Object.keys(updateDoc.$set).length === 0) {
        return { error: "No update fields provided." };
      }

      const result = await this.policies.updateOne({ _id: policyId }, updateDoc);

      if (result.matchedCount === 0) {
        return { error: "Policy not found." };
      }
      return {};
    } catch (e) {
      console.error("Error updating policy:", e);
      return { error: "Failed to update policy due to a database error." };
    }
  }

  /**
   * deletePolicy(policy: Policy)
   *
   * requires policy exists
   * effect removes policy and any default policy mappings for this policy
   * note does not affect existing reminders that were already instantiated
   */
  async deletePolicy(
    { policy: policyId }: { policy: Policy },
  ): Promise<Empty | { error: string }> {
    try {
      const result = await this.policies.deleteOne({ _id: policyId });
      if (result.deletedCount === 0) {
        return { error: "Policy not found." };
      }

      // Also remove any default policy mappings that point to this policy
      await this.defaultPolicies.deleteMany({ policy: policyId });

      return {};
    } catch (e) {
      console.error("Error deleting policy:", e);
      return { error: "Failed to delete policy due to a database error." };
    }
  }

  /**
   * setDefaultPolicy(user: User, tag: Tag, policy: Policy)
   *
   * requires policy exists, policy belongs to user, tag is in policy tags
   * effect sets policy as default for (user, tag) combination
   * note replaces any existing default for this combination
   */
  async setDefaultPolicy(
    { user, tag, policy: policyId }: { user: User; tag: Tag; policy: Policy },
  ): Promise<Empty | { error: string }> {
    if (!tag.trim()) {
      return { error: "Tag cannot be empty." };
    }
    try {
      const policyDoc = await this.policies.findOne({ _id: policyId, user });
      if (!policyDoc) {
        return { error: "Policy not found or does not belong to the user." };
      }
      if (!policyDoc.tags.includes(tag)) {
        return { error: `Policy '${policyId}' does not contain the tag '${tag}'.` };
      }

      // Use upsert to create or replace the default policy entry
      await this.defaultPolicies.updateOne(
        { user, tag },
        { $set: { user, tag, policy: policyId }, $setOnInsert: { _id: freshID() } },
        { upsert: true },
      );

      return {};
    } catch (e) {
      console.error("Error setting default policy:", e);
      return { error: "Failed to set default policy due to a database error." };
    }
  }

  /**
   * _getPersonalization(user: User, tag: Tag): Map<String,Any>?
   *
   * effect returns personalization data for (user, tag) or none if not learned
   * note this is a query method (starts with underscore)
   */
  async _getPersonalization(
    { user, tag }: { user: User; tag: Tag },
  ): Promise<Map<string, unknown> | null> {
    if (!tag.trim()) {
      return null; // Or { error: "Tag cannot be empty." } for query too
    }
    try {
      const personalization = await this.personalizations.findOne({ user, tag });
      if (personalization) {
        // Exclude _id from the returned map, or include if desired.
        // For _getPersonalization, returning the full doc might be fine.
        return new Map(Object.entries(personalization));
      }
      return null;
    } catch (e) {
      console.error("Error getting personalization:", e);
      return null;
    }
  }
}
```
