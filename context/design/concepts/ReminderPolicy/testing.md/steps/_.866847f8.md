---
timestamp: 'Thu Oct 16 2025 21:54:49 GMT-0400 (Eastern Daylight Time)'
parent: '[[..\20251016_215449.5ff0e898.md]]'
content_id: 866847f853c6f9a33fa68a7e7ad3f09e125ac620de965894ede8d88b85944999
---

# Test implementation

While testing, use the `testDb` function, which returns a tuple of the database and client so that you can close it.

```typescript
import { testDb } from "@utils/database.ts";

Deno.test("...", async () => {
  const [db, client] = await testDb();

  // ... tests

  await client.close();
});
```

The database is already automatically dropped before every test file using the `Deno.test.beforeAll` hook: do not include any additional manipulation of the database for this purpose.

Use the Deno.test framework, splitting by appropriate test steps and describing each behavior. Import helpers from:

```typescript
import { assertEquals } from "jsr:@std/assert"; // or any other utility from the library
```

\<concept\_spec>
concept ReminderPolicy \[User, Policy]

purpose
manage reusable reminder templates that adapt to user behavior and event types

principle
after selecting a policy for an event type, generates personalized reminders based on learned patterns;
users define default policies with timing rules (e.g., 24 hours before, 30 minutes before);
system learns from user behavior (early dismissals, snoozes) and adjusts future reminder times;
policies are matched to events via tags, with personalization applied during instantiation

operational principle
after user creates a policy "Class Reminders" for tag "class" with rules (24 hours before: email, 30 minutes before: notification),
user attaches "class" tag to an event starting at 2pm tomorrow;
selectPolicy returns "Class Reminders";
instantiate generates reminders at 2pm today (email) and 1:30pm tomorrow (notification);
over time, user dismisses 30-min notifications early;
learn() records that 45-min offset is more effective;
future instantiate() calls blend 30min rule with 45min learned offset based on effectiveness score

state
a set of Policy with
a user User
a name String
tags Set<Tag>
rules Sequence<Rule> // ordered list of reminder rules

```
where Rule has
    an offset Number // minutes before event
    a type ReminderType // "notification", "email", "sms"

a set of Personalization with
    a user User
    a tag Tag
    an avgOffset Number // learned average offset in minutes
    an effectiveness Float // 0.0-1.0 score for personalization effectiveness

a set of DefaultPolicy with
    a user User
    a tag Tag
    a policy Policy // default policy for this user-tag combination

invariants
    every Policy belongs to exactly one user
    offset values are positive numbers
    effectiveness scores are between 0.0 and 1.0
    every Rule in a policy has a valid ReminderType
    if DefaultPolicy exists for (user, tag), policy must have that tag in its tags set
```

actions
createPolicy(user: User, name: String, tags: Set<Tag>, rules: Sequence<Rule>): Policy
requires name is non-empty, rules is non-empty, all offsets are positive
effect creates new policy and sets as default for tags if no default exists
note returns the created policy ID

```
selectPolicy(user: User, tags: Set<Tag>): Policy?
    requires tags is non-empty
    effect finds policy matching most tags; checks default policies if no exact match
    note returns best matching policy or none if no policy matches
    note prioritizes policies with maximum tag overlap

instantiate(user: User, policy: Policy, eventStart: DateTime): Sequence<Reminder>
    requires policy exists, policy belongs to user
    effect generates reminders by applying policy rules with personalization adjustments
    note blends rule offset with learned offset based on effectiveness score
    note returns list of reminders with absolute times and types

learn(user: User, tag: Tag, actualOffset: Number, wasEffective: Boolean)
    requires actualOffset is positive
    effect updates personalization data using exponential moving average
    note increases effectiveness score if wasEffective, decreases otherwise
    note creates new personalization entry if none exists for (user, tag)

getPolicy(policy: Policy): Map<String,Any>
    requires policy exists
    effect returns policy data including name, tags, and rules

getUserPolicies(user: User): Set<Policy>
    effect returns all policies for the user

updatePolicy(policy: Policy, name: String?, rules: Sequence<Rule>?)
    requires policy exists, if rules provided then non-empty
    effect updates policy name and/or rules
    note does not affect existing reminders, only future instantiations

deletePolicy(policy: Policy)
    requires policy exists
    effect removes policy and any default policy mappings for this policy
    note does not affect existing reminders that were already instantiated

setDefaultPolicy(user: User, tag: Tag, policy: Policy)
    requires policy exists, policy belongs to user, tag is in policy tags
    effect sets policy as default for (user, tag) combination
    note replaces any existing default for this combination

getPersonalization(user: User, tag: Tag): Map<String,Any>?
    effect returns personalization data for (user, tag) or none if not learned
```

notes
Reminder generation uses adaptive blending:
\- Initial effectiveness is 0.5 (50% rule, 50% learned)
\- As effectiveness increases toward 1.0, learned offset dominates
\- If effectiveness decreases toward 0.0, rule offset dominates
\- Formula: adjustedOffset = ruleOffset × (1 - effectiveness) + learnedOffset × effectiveness

```
Learning adapts to user behavior:
- Early dismissals suggest longer lead time needed
- Snoozes suggest shorter lead time appropriate
- Learning rate (alpha = 0.3) balances stability and adaptation
- Effectiveness adjusts ±0.1 per feedback event

Policy selection prioritizes specificity:
- Exact tag matches preferred over partial matches
- Number of matching tags determines best policy
- Default policies serve as fallback for common tags

ReminderType determines delivery mechanism:
- "notification": push notification to device
- "email": email sent to user
- "sms": text message (requires phone number)

Tags enable flexible policy application:
- Common tags: "class", "meeting", "appointment", "deadline", "birthday"
- Users can define custom tags for specific needs
- Multiple tags allow policy selection based on event characteristics
```

\</concept\_spec>
