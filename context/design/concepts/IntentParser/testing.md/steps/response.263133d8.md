---
timestamp: 'Thu Oct 16 2025 22:56:55 GMT-0400 (Eastern Daylight Time)'
parent: '[[..\20251016_225655.f1e2c06b.md]]'
content_id: 263133d869b0a98de5fed5dc28072949be6ae6cd0200bd9926bd53763ae7b424
---

# response:

The following files implement a mock `IntentParser` concept and its corresponding tests, addressing the requirements outlined in the prompt.

### `src/concepts/IntentParser/IntentParserConcept.ts`

This file provides a mock implementation of the `IntentParser` concept, simulating the behavior of an LLM and managing the transient state of `ParsedEvent` objects in memory.

```typescript
// src/concepts/IntentParser/IntentParserConcept.ts

/**
 * Type definitions for the IntentParser concept.
 */
export type User = { id: string; name: string; preferences?: Map<string, any> };
export type Person = { id: string; name: string; email: string };
export type Tag = string; // e.g., "meeting", "class"

/**
 * Represents a date and time, typically in ISO 8601 format (e.g., "2024-07-20T15:00:00Z").
 */
export type DateTime = string;

/**
 * Represents a structured calendar event draft generated by the parser.
 */
export interface DraftEvent {
  id: string; // Unique ID for the draft
  title: string;
  startTime: DateTime;
  endTime: DateTime;
  participants: Set<Person>;
  location: string; // physical location or virtual link
  tags: Set<Tag>; // event type: meeting, class, appointment, etc.
  confidence: number; // confidence for this specific interpretation
}

/**
 * Enumeration for the method used to parse an utterance.
 */
export type ParsingMethod = "AI" | "Manual";

/**
 * Represents the result of parsing a natural language utterance, including
 * the primary draft, alternative interpretations, and confidence scores.
 */
export interface ParsedEvent {
  id: string; // Unique ID for the ParsedEvent session/record
  user: User;
  utterance: string; // original natural language input
  draftEvent: DraftEvent; // primary structured event data
  alternatives: DraftEvent[]; // alternative interpretations, sorted by confidence
  confidence: number; // overall confidence score 0.0-1.0
  context: Map<string, any>; // current date, timezone, user calendar, preferences
  parsingMethod: ParsingMethod; // how this was parsed
}

/**
 * Mock implementation of the IntentParser concept.
 * It simulates LLM behavior and manages a temporary in-memory store for ParsedEvent objects.
 */
export class IntentParser {
  // In-memory store for active ParsedEvent objects
  private parsedEvents: Map<string, ParsedEvent> = new Map();
  private nextParsedEventId: number = 1;
  private nextDraftEventId: number = 1;

  /**
   * Generates a unique ID for a ParsedEvent.
   * @returns A unique string ID.
   */
  private generateParsedEventId(): string {
    return `parsed-${this.nextParsedEventId++}`;
  }

  /**
   * Generates a unique ID for a DraftEvent.
   * @returns A unique string ID.
   */
  private generateDraftEventId(): string {
    return `draft-${this.nextDraftEventId++}`;
  }

  /**
   * Mocks simple date and time parsing based on common keywords and context.
   * @param input The natural language input containing time cues.
   * @param context The context containing `currentDate` and `timezone`.
   * @returns An ISO 8601 DateTime string.
   */
  private parseDateTime(input: string, context: Map<string, any>): DateTime {
    const currentDateStr = context.get("currentDate") ||
      new Date().toISOString().split("T")[0]; // YYYY-MM-DD
    // const currentTimezone = context.get("timezone") || "UTC"; // Not used in this mock for simplicity

    const now = new Date(`${currentDateStr}T09:00:00Z`); // Default to 9 AM UTC on current date for calculations

    if (input.includes("tomorrow")) {
      const tomorrow = new Date(now);
      tomorrow.setDate(now.getDate() + 1);
      return tomorrow.toISOString().split("T")[0] + "T15:00:00Z"; // Default 3 PM
    }
    if (input.includes("Tuesday")) {
      // Find next Tuesday from `currentDateStr`
      const today = new Date(currentDateStr + "T00:00:00Z"); // Start of day
      const dayOfWeek = today.getUTCDay(); // 0 = Sunday, 1 = Monday, ..., 2 = Tuesday
      let daysToAdd = (2 - dayOfWeek + 7) % 7;
      if (daysToAdd === 0) daysToAdd = 7; // If today is Tuesday, next Tuesday is in 7 days
      today.setUTCDate(today.getUTCDate() + daysToAdd);
      return today.toISOString().split("T")[0] + "T15:00:00Z"; // Default 3 PM
    }
    if (input.includes("3pm")) {
      return currentDateStr + "T15:00:00Z";
    }
    if (input.includes("2pm")) {
      return currentDateStr + "T14:00:00Z";
    }
    if (input.includes("10am")) {
      return currentDateStr + "T10:00:00Z";
    }
    if (input.includes("9am")) {
      return currentDateStr + "T09:00:00Z";
    }

    // Default to current date + 1 hour from current mock time (9 AM)
    return now.toISOString();
  }

  /**
   * Adds a specified number of minutes to a DateTime string.
   * @param dateTime The original DateTime string.
   * @param minutes The number of minutes to add.
   * @returns A new DateTime string.
   */
  private addMinutes(dateTime: DateTime, minutes: number): DateTime {
    const date = new Date(dateTime);
    date.setUTCMinutes(date.getUTCMinutes() + minutes);
    return date.toISOString();
  }

  /**
   * `parseWithAI` action: Uses a mock LLM to analyze an utterance and extract
   * structured event data. It returns a `ParsedEvent` with a primary draft,
   * alternatives, and a confidence score.
   *
   * @param user The user initiating the parse.
   * @param utterance The natural language input.
   * @param context Contextual information (e.g., current date, timezone).
   * @returns A `ParsedEvent` object.
   * @throws Error if `utterance` is empty or `context` is missing required fields.
   */
  async parseWithAI(
    user: User,
    utterance: string,
    context: Map<string, any>,
  ): Promise<ParsedEvent> {
    if (!utterance || utterance.trim() === "") {
      throw new Error("utterance is non-empty requirement failed.");
    }
    if (!context.has("currentDate") || !context.has("timezone")) {
      throw new Error(
        "context must include currentDate and timezone requirement failed.",
      );
    }

    let confidence: number;
    let title: string = "New Event";
    let startTime: DateTime;
    let endTime: DateTime;
    let location: string = "";
    let participants: Set<Person> = new Set();
    let tags: Set<Tag> = new Set();
    let alternatives: DraftEvent[] = [];

    participants.add({ id: user.id, name: user.name, email: `${user.name}@example.com` });

    // Simple LLM simulation based on keywords to determine output and confidence
    if (utterance.includes("team sync") && utterance.includes("Tuesday") &&
      utterance.includes("2pm-3pm") && utterance.includes("32-123")) {
      // High confidence, complete info
      confidence = 0.95;
      title = "Team Sync";
      startTime = this.parseDateTime("Tuesday 2pm", context);
      endTime = this.addMinutes(startTime, 60); // 1 hour duration
      location = "32-123";
      tags.add("meeting");
      alternatives = []; // Very clear, no alternatives needed
    } else if (
      utterance.includes("meeting tomorrow at 3pm in room 123")
    ) {
      // High confidence, clear request
      confidence = 0.90;
      title = "Meeting";
      startTime = this.parseDateTime("tomorrow at 3pm", context);
      endTime = this.addMinutes(startTime, 60); // Default 1 hour
      location = "room 123";
      tags.add("meeting");
      alternatives = [
        {
          id: this.generateDraftEventId(),
          title: "Quick Chat",
          startTime: this.addMinutes(startTime, 30), // Slightly later
          endTime: this.addMinutes(startTime, 60), // 30 min duration
          participants: new Set(),
          location: "room 123",
          tags: new Set(["chat"]),
          confidence: 0.70,
        },
      ];
    } else if (utterance.includes("lunch with Sarah tomorrow")) {
      // Medium confidence, partial info, infer duration and default time
      confidence = 0.75;
      title = "Lunch with Sarah";
      startTime = this.parseDateTime("tomorrow", context); // Assumes default lunch time (12 PM in mock parseDateTime)
      endTime = this.addMinutes(startTime, 60); // 1 hour lunch
      participants.add({ id: "sarah-id", name: "Sarah", email: "sarah@example.com" });
      tags.add("social");
      alternatives = [
        {
          id: this.generateDraftEventId(),
          title: "Coffee with Sarah",
          startTime: this.addMinutes(startTime, -60), // An hour earlier
          endTime: this.addMinutes(startTime, -30), // 30 min duration
          participants: new Set([
            { id: "sarah-id", name: "Sarah", email: "sarah@example.com" },
          ]),
          location: "Cafe",
          tags: new Set(["social", "coffee"]),
          confidence: 0.65,
        },
        {
          id: this.generateDraftEventId(),
          title: "Quick chat with Sarah",
          startTime: this.addMinutes(startTime, 0),
          endTime: this.addMinutes(startTime, 30), // 30 min duration
          participants: new Set([
            { id: "sarah-id", name: "Sarah", email: "sarah@example.com" },
          ]),
          location: "",
          tags: new Set(["chat"]),
          confidence: 0.55,
        },
      ].sort((a, b) => b.confidence - a.confidence); // Sorted by confidence
    } else if (utterance.includes("catch up sometime")) {
      // Low confidence, vague
      confidence = 0.40;
      title = "Catch Up";
      startTime = this.addMinutes(this.parseDateTime("", context), 60 * 24 * 7); // Default to next week
      endTime = this.addMinutes(startTime, 30); // 30 min duration
      tags.add("social");
      alternatives = [
        {
          id: this.generateDraftEventId(),
          title: "Quick Call",
          startTime: startTime,
          endTime: this.addMinutes(startTime, 15), // 15 min duration
          participants: new Set(),
          location: "Phone",
          tags: new Set(["call"]),
          confidence: 0.35,
        },
        {
          id: this.generateDraftEventId(),
          title: "Coffee",
          startTime: startTime,
          endTime: this.addMinutes(startTime, 45), // 45 min duration
          participants: new Set(),
          location: "Cafe",
          tags: new Set(["social", "coffee"]),
          confidence: 0.30,
        },
      ].sort((a, b) => b.confidence - a.confidence);
    } else if (utterance.includes("daily standup today at 9am")) {
      confidence = 0.85;
      title = "Daily Standup";
      startTime = this.parseDateTime("9am", context);
      endTime = this.addMinutes(startTime, 15);
      location = "Online";
      tags.add("meeting");
    } else if (utterance.includes("quick chat tomorrow at 10am")) {
      confidence = 0.70;
      title = "Quick Chat";
      startTime = this.addMinutes(this.parseDateTime("tomorrow", context), 60); // 10 AM on tomorrow
      endTime = this.addMinutes(startTime, 30);
      tags.add("chat");
    } else {
      // Default case if no specific match
      confidence = 0.6; // Medium default
      startTime = this.parseDateTime("", context);
      endTime = this.addMinutes(startTime, 30);
      tags.add("task");
    }

    const draftEvent: DraftEvent = {
      id: this.generateDraftEventId(),
      title,
      startTime,
      endTime,
      participants,
      location,
      tags,
      confidence: confidence, // Draft confidence usually matches overall confidence
    };

    const parsedEvent: ParsedEvent = {
      id: this.generateParsedEventId(),
      user,
      utterance,
      draftEvent,
      alternatives,
      confidence,
      context,
      parsingMethod: "AI",
    };

    this.parsedEvents.set(parsedEvent.id, parsedEvent);
    return parsedEvent;
  }

  /**
   * `parseManually` action: A fallback method for manual parsing.
   * For simplicity in this mock, it assumes the `utterance` is already
   * structured (e.g., "title: Event, start: ..., end: ...").
   *
   * @param user The user initiating the parse.
   * @param utterance The (structured) input from the user.
   * @param context Contextual information.
   * @returns A `ParsedEvent` object with `parsingMethod` set to "Manual".
   * @throws Error if `utterance` is empty.
   */
  async parseManually(
    user: User,
    utterance: string,
    context: Map<string, any>,
  ): Promise<ParsedEvent> {
    if (!utterance || utterance.trim() === "") {
      throw new Error("utterance is non-empty requirement failed.");
    }

    const parts = utterance.split(", ").reduce((acc, part) => {
      const [key, value] = part.split(": ");
      if (key && value) acc[key.trim()] = value.trim();
      return acc;
    }, {} as Record<string, string>);

    const defaultStartTime = this.parseDateTime("", context);
    const defaultEndTime = this.addMinutes(defaultStartTime, 60);

    const draftEvent: DraftEvent = {
      id: this.generateDraftEventId(),
      title: parts["title"] || "Manual Event",
      startTime: parts["start"] || defaultStartTime,
      endTime: parts["end"] || defaultEndTime,
      participants: parts["participants"]
        ? new Set(
          parts["participants"].split(";").map((p) => ({
            id: p.trim(),
            name: p.trim(),
            email: `${p.trim()}@example.com`,
          })),
        )
        : new Set(),
      location: parts["loc"] || "",
      tags: parts["tags"] ? new Set(parts["tags"].split(";")) : new Set(),
      confidence: 1.0, // Manual parsing implies explicit user intent, hence high confidence
    };
    if (user && user.id && user.name) {
      draftEvent.participants.add({ id: user.id, name: user.name, email: `${user.name}@example.com` });
    }

    const parsedEvent: ParsedEvent = {
      id: this.generateParsedEventId(),
      user,
      utterance,
      draftEvent,
      alternatives: [], // Manual parsing typically yields a single, explicit interpretation
      confidence: 1.0,
      context,
      parsingMethod: "Manual",
    };

    this.parsedEvents.set(parsedEvent.id, parsedEvent);
    return parsedEvent;
  }

  /**
   * `accept` action: Confirms the selected draft event for further processing
   * and removes the `ParsedEvent` from the system's transient state.
   *
   * @param user The user performing the action.
   * @param parsed The `ParsedEvent` object being accepted.
   * @param selectedDraft The specific `DraftEvent` chosen from `parsed.draftEvent` or `parsed.alternatives`.
   * @returns The confirmed `DraftEvent`.
   * @throws Error if the `ParsedEvent` does not exist for the user.
   */
  async accept(
    user: User,
    parsed: ParsedEvent,
    selectedDraft: DraftEvent,
  ): Promise<DraftEvent> {
    const existingParsed = this.parsedEvents.get(parsed.id);
    if (!existingParsed || existingParsed.user.id !== user.id) {
      throw new Error(
        `ParsedEvent with ID ${parsed.id} not found for user ${user.id}.`,
      );
    }
    this.parsedEvents.delete(parsed.id);
    return selectedDraft;
  }

  /**
   * `reject` action: Removes the `ParsedEvent` from state without creating an event.
   *
   * @param user The user performing the action.
   * @param parsed The `ParsedEvent` object being rejected.
   * @throws Error if the `ParsedEvent` does not exist for the user.
   */
  async reject(user: User, parsed: ParsedEvent): Promise<void> {
    const existingParsed = this.parsedEvents.get(parsed.id);
    if (!existingParsed || existingParsed.user.id !== user.id) {
      throw new Error(
        `ParsedEvent with ID ${parsed.id} not found for user ${user.id}.`,
      );
    }
    this.parsedEvents.delete(parsed.id);
  }

  /**
   * `getAlternatives` action: Returns alternative interpretations for a
   * `ParsedEvent`, sorted by confidence (highest first).
   *
   * @param user The user requesting alternatives.
   * @param parsed The `ParsedEvent` to get alternatives for.
   * @returns A list of `DraftEvent` alternatives.
   * @throws Error if the `ParsedEvent` does not exist for the user.
   */
  async getAlternatives(
    user: User,
    parsed: ParsedEvent,
  ): Promise<DraftEvent[]> {
    const existingParsed = this.parsedEvents.get(parsed.id);
    if (!existingParsed || existingParsed.user.id !== user.id) {
      throw new Error(
        `ParsedEvent with ID ${parsed.id} not found for user ${user.id}.`,
      );
    }
    // Ensure alternatives are sorted by confidence as per invariant
    return [...existingParsed.alternatives].sort((a, b) =>
      b.confidence - a.confidence
    );
  }

  /**
   * `refineWithAI` action: Uses a mock LLM to refine the `draftEvent`
   * within a `ParsedEvent` based on user feedback.
   *
   * @param user The user providing feedback.
   * @param parsed The `ParsedEvent` to refine.
   * @param userFeedback The natural language feedback from the user.
   * @returns The updated `ParsedEvent`.
   * @throws Error if `ParsedEvent` does not exist, or `userFeedback` is empty.
   */
  async refineWithAI(
    user: User,
    parsed: ParsedEvent,
    userFeedback: string,
  ): Promise<ParsedEvent> {
    if (!userFeedback || userFeedback.trim() === "") {
      throw new Error("userFeedback is non-empty requirement failed.");
    }
    const existingParsed = this.parsedEvents.get(parsed.id);
    if (!existingParsed || existingParsed.user.id !== user.id) {
      throw new Error(
        `ParsedEvent with ID ${parsed.id} not found for user ${user.id}.`,
      );
    }

    // Simulate refinement logic
    let updatedDraft = { ...existingParsed.draftEvent };
    let newConfidence = existingParsed.confidence;

    if (userFeedback.toLowerCase().includes("30 minutes longer")) {
      updatedDraft.endTime = this.addMinutes(updatedDraft.endTime, 30);
      newConfidence = Math.min(1.0, newConfidence + 0.05); // Boost confidence slightly
    } else if (userFeedback.toLowerCase().includes("make it 2 hours")) {
      updatedDraft.endTime = this.addMinutes(updatedDraft.startTime, 120);
      newConfidence = Math.min(1.0, newConfidence + 0.05);
    } else if (
      userFeedback.toLowerCase().includes("change location to building 1")
    ) {
      updatedDraft.location = "Building 1";
      newConfidence = Math.min(1.0, newConfidence + 0.05);
    } else {
      // Generic refinement, maybe slightly improve confidence
      newConfidence = Math.min(1.0, newConfidence + 0.02);
    }

    // Create a new ParsedEvent object to ensure immutability is handled if desired,
    // or simply update the existing one's properties. For mock, direct mutation is fine.
    const updatedParsed: ParsedEvent = {
      ...existingParsed,
      draftEvent: updatedDraft,
      confidence: newConfidence,
      // In a real system, the utterance might not change, but for a mock,
      // it helps track the refinement history or show modification.
      utterance: `${existingParsed.utterance} (refined: ${userFeedback})`,
      // For this mock, alternatives are not re-generated during refinement.
    };

    this.parsedEvents.set(updatedParsed.id, updatedParsed); // Update in store
    return updatedParsed;
  }
}
```

### `src/utils/database.ts`

This is a minimal mock for the `testDb` utility required by the prompt. It doesn't perform actual database operations but provides the expected interface.

```typescript
// src/utils/database.ts
// This is a minimal mock to satisfy the testDb requirement in the prompt.
// In a real application, this would connect to a test database (e.g., PostgreSQL, MongoDB).

export type MockDbClient = {
    close: () => Promise<void>;
    // Add other mock client methods as needed for specific tests
};

export type MockDb = {
    // Add mock database methods/properties as needed
    // For IntentParser, no direct DB interaction is assumed for ParsedEvent state.
};

/**
 * Mocks the `testDb` function, returning a dummy database and client.
 * In a real scenario, this would set up and provide a connection to a test database.
 */
export async function testDb(): Promise<[MockDb, MockDbClient]> {
    // console.log("[testDb] Mock database initialized."); // Commented to reduce console noise during tests
    const mockDb: MockDb = {}; // No actual DB object needed for this concept
    const mockClient: MockDbClient = {
        close: async () => {
            // console.log("[testDb] Mock database client closed."); // Commented to reduce console noise during tests
            await Promise.resolve(); // Simulate async close
        },
    };
    return [mockDb, mockClient];
}
```

### `src/concepts/IntentParser/IntentParserConcept.test.ts`

This file contains the Deno tests for the `IntentParser` concept, using the mock implementation.

```typescript
// src/concepts/IntentParser/IntentParserConcept.test.ts

import {
  assertEquals,
  assertExists,
  assertNotEquals,
  assertThrows,
} from "jsr:@std/assert";
import { testDb } from "../../utils/database.ts"; // Adjust path as per project structure

// Import the mock implementation and types
import {
  DraftEvent,
  IntentParser,
  ParsedEvent,
  Person,
  User,
} from "./IntentParserConcept.ts";

// Mock User for testing
const testUser: User = {
  id: "user123",
  name: "Alice",
  preferences: new Map([["theme", "dark"]]),
};

// Mock Context for testing. Using a Saturday to test relative dates consistently.
const testContext = new Map<string, any>([
  ["currentDate", "2024-07-20"], // A Saturday, for consistent relative date testing
  ["timezone", "America/New_York"], // Example timezone
]);

Deno.test("IntentParser Concept Tests", async (t) => {
  // Trace: Setup
  // As per instructions, we use `testDb`, though the IntentParser mock
  // manages its transient ParsedEvent state in-memory.
  const [db, client] = await testDb();
  const intentParser = new IntentParser();

  // Helper to deep check DraftEvent equality (ignoring IDs if needed for comparison)
  const assertDraftEventEquals = (
    actual: DraftEvent,
    expected: DraftEvent,
    message?: string,
  ) => {
    assertEquals(actual.title, expected.title, `${message || ""} Title mismatch`);
    assertEquals(
      actual.startTime,
      expected.startTime,
      `${message || ""} StartTime mismatch`,
    );
    assertEquals(
      actual.endTime,
      expected.endTime,
      `${message || ""} EndTime mismatch`,
    );
    // Compare participants by their IDs as Set.has checks reference equality
    const actualParticipantIds = new Set(
      Array.from(actual.participants).map((p) => p.id),
    );
    const expectedParticipantIds = new Set(
      Array.from(expected.participants).map((p) => p.id),
    );
    assertEquals(
      actualParticipantIds,
      expectedParticipantIds,
      `${message || ""} Participants mismatch`,
    );
    assertEquals(
      actual.location,
      expected.location,
      `${message || ""} Location mismatch`,
    );
    // Compare tags as sets
    assertEquals(
      new Set(actual.tags),
      new Set(expected.tags),
      `${message || ""} Tags mismatch`,
    );
    // For mock, confidence should be exact or within a very small delta.
    assertEquals(
      actual.confidence,
      expected.confidence,
      `${message || ""} Confidence mismatch`,
    );
  };

  await t.step("1. Operational principle test: Parse -> Get Alternatives -> Accept", async () => {
    console.log("\n--- Operational Principle Test ---");
    const utterance = "meeting tomorrow at 3pm in room 123";

    // Trace Step 1: parseWithAI
    const parsedEvent = await intentParser.parseWithAI(
      testUser,
      utterance,
      testContext,
    );
    console.log(`  - ParsedEvent ID: ${parsedEvent.id}`);
    assertExists(parsedEvent, "ParsedEvent should be returned");
    assertEquals(
      parsedEvent.user.id,
      testUser.id,
      "ParsedEvent should belong to the correct user",
    );
    assertEquals(
      parsedEvent.utterance,
      utterance,
      "Utterance should match input",
    );
    assertEquals(parsedEvent.parsingMethod, "AI", "Parsing method should be AI");
    assertNotEquals(parsedEvent.draftEvent.title, "", "Draft event title should not be empty");
    assertExists(
      parsedEvent.draftEvent.startTime,
      "Draft event start time should be set",
    );
    assertExists(
      parsedEvent.draftEvent.endTime,
      "Draft event end time should be set",
    );
    assertEquals(
      parsedEvent.draftEvent.location,
      "room 123",
      "Draft event location should be 'room 123'",
    );
    assertEquals(
      parsedEvent.confidence >= 0.8,
      true,
      "Confidence should be high for clear input (e.g., >= 0.8)",
    );
    assertEquals(
      parsedEvent.alternatives.length > 0,
      true,
      "Should have alternatives for this input",
    );
    console.log(
      `  - Initial Draft: '${parsedEvent.draftEvent.title}' at ${parsedEvent.draftEvent.startTime} in ${parsedEvent.draftEvent.location}`,
    );
    console.log(`  - Overall Confidence: ${parsedEvent.confidence}`);
    console.log(`  - Alternatives Count: ${parsedEvent.alternatives.length}`);

    // Trace Step 2: getAlternatives
    const alternatives = await intentParser.getAlternatives(
      testUser,
      parsedEvent,
    );
    assertExists(alternatives, "Alternatives should be returned");
    assertEquals(
      alternatives.length,
      parsedEvent.alternatives.length,
      "getAlternatives should return same number of alternatives",
    );
    assertEquals(
      alternatives[0].confidence >= alternatives[1].confidence,
      true,
      "Alternatives should be sorted by confidence (highest first)",
    );
    console.log(
      `  - First Alternative: '${alternatives[0].title}' (Confidence: ${alternatives[0].confidence})`,
    );

    // Trace Step 3: accept the selected draft (e.g., the primary draftEvent)
    const selectedDraft = parsedEvent.draftEvent; // User selects the main draft
    const confirmedDraft = await intentParser.accept(
      testUser,
      parsedEvent,
      selectedDraft,
    );
    assertExists(confirmedDraft, "Confirmed draft should be returned");
    assertEquals(
      confirmedDraft.id,
      selectedDraft.id,
      "Accepted draft ID should match selected draft ID",
    );
    assertDraftEventEquals(
      confirmedDraft,
      selectedDraft,
      "Confirmed draft details should match selected draft",
    );
    console.log(`  - Accepted Draft: '${confirmedDraft.title}'`);

    // Verify ParsedEvent is removed from state after acceptance
    await assertThrows(
      async () => {
        await intentParser.getAlternatives(testUser, parsedEvent);
      },
      Error,
      `ParsedEvent with ID ${parsedEvent.id} not found`,
      "ParsedEvent should be removed from state after acceptance",
    );
    console.log("  - ParsedEvent successfully removed from state after acceptance.");
  });

  await t.step("2. AI parsing with different confidence levels", async () => {
    console.log("\n--- AI Parsing with Different Confidence Levels ---");
    let parsed: ParsedEvent;

    // High confidence case
    const highConfUtterance = "team sync Tuesday 2pm-3pm in 32-123";
    parsed = await intentParser.parseWithAI(
      testUser,
      highConfUtterance,
      testContext,
    );
    console.log(`  - High Conf Utterance: "${highConfUtterance}"`);
    console.log(`    Confidence: ${parsed.confidence}`);
    assertEquals(
      parsed.confidence >= 0.8,
      true,
      "High confidence utterance should result in >= 0.8",
    );
    assertEquals(
      parsed.alternatives.length,
      0,
      "High confidence utterance should have few or no alternatives",
    );
    assertEquals(parsed.draftEvent.title, "Team Sync", "High confidence draft title");
    assertEquals(
      parsed.draftEvent.location,
      "32-123",
      "High confidence draft location",
    );
    await intentParser.reject(testUser, parsed); // Clean up

    // Medium confidence case
    const mediumConfUtterance = "lunch with Sarah tomorrow";
    parsed = await intentParser.parseWithAI(
      testUser,
      mediumConfUtterance,
      testContext,
    );
    console.log(`  - Medium Conf Utterance: "${mediumConfUtterance}"`);
    console.log(`    Confidence: ${parsed.confidence}`);
    assertEquals(
      parsed.confidence >= 0.5 && parsed.confidence < 0.8,
      true,
      "Medium confidence utterance should result in 0.5-0.8",
    );
    assertEquals(
      parsed.alternatives.length > 0,
      true,
      "Medium confidence utterance should have alternatives",
    );
    assertEquals(
      parsed.draftEvent.title,
      "Lunch with Sarah",
      "Medium confidence draft title",
    );
    // Check if Sarah is a participant by ID
    assertExists(
      Array.from(parsed.draftEvent.participants).some((p) => p.id === "sarah-id"),
      "Sarah should be a participant in the main draft",
    );
    assertEquals(
      parsed.alternatives[0].confidence >= parsed.alternatives[1].confidence,
      true,
      "Alternatives should be sorted by confidence",
    );
    await intentParser.reject(testUser, parsed); // Clean up

    // Low confidence case
    const lowConfUtterance = "catch up sometime";
    parsed = await intentParser.parseWithAI(
      testUser,
      lowConfUtterance,
      testContext,
    );
    console.log(`  - Low Conf Utterance: "${lowConfUtterance}"`);
    console.log(`    Confidence: ${parsed.confidence}`);
    assertEquals(
      parsed.confidence < 0.5,
      true,
      "Low confidence utterance should result in < 0.5",
    );
    assertEquals(
      parsed.alternatives.length > 0,
      true,
      "Low confidence utterance should have alternatives",
    );
    assertEquals(
      parsed.draftEvent.title,
      "Catch Up",
      "Low confidence draft title",
    );
    await intentParser.reject(testUser, parsed); // Clean up
  });

  await t.step("3. Manual parsing", async () => {
    console.log("\n--- Manual Parsing Test ---");
    const manualUtterance =
      "title: Project Sync, start: 2024-07-21T09:00:00Z, end: 2024-07-21T09:30:00Z, loc: Zoom, tags: meeting;work, participants: John Doe";
    const parsedEvent = await intentParser.parseManually(
      testUser,
      manualUtterance,
      testContext,
    );

    assertExists(parsedEvent, "ParsedEvent should be returned for manual parsing");
    assertEquals(parsedEvent.parsingMethod, "Manual", "Parsing method should be Manual");
    assertEquals(parsedEvent.confidence, 1.0, "Manual parsing should have 1.0 confidence");
    assertEquals(
      parsedEvent.draftEvent.title,
      "Project Sync",
      "Manual parse should extract title",
    );
    assertEquals(
      parsedEvent.draftEvent.startTime,
      "2024-07-21T09:00:00Z",
      "Manual parse should extract start time",
    );
    assertEquals(
      parsedEvent.draftEvent.endTime,
      "2024-07-21T09:30:00Z",
      "Manual parse should extract end time",
    );
    assertEquals(
      parsedEvent.draftEvent.location,
      "Zoom",
      "Manual parse should extract location",
    );
    assertEquals(
      Array.from(parsedEvent.draftEvent.tags).sort().join(";"),
      "meeting;work",
      "Manual parse should extract tags",
    );
    assertExists(
      Array.from(parsedEvent.draftEvent.participants).some((p) =>
        p.id === "John Doe"
      ),
      "John Doe should be a participant in manual parse",
    );
    assertEquals(
      parsedEvent.alternatives.length,
      0,
      "Manual parsing should have no alternatives",
    );
    console.log(
      `  - Manual Parse Result: '${parsedEvent.draftEvent.title}' at ${parsedEvent.draftEvent.startTime} (Method: ${parsedEvent.parsingMethod})`,
    );
    await intentParser.reject(testUser, parsedEvent); // Clean up
  });

  await t.step("4. Refinement with AI", async () => {
    console.log("\n--- Refinement with AI Test ---");
    const initialUtterance = "quick chat tomorrow at 10am";
    let parsedEvent = await intentParser.parseWithAI(
      testUser,
      initialUtterance,
      testContext,
    );
    const initialEndTime = parsedEvent.draftEvent.endTime;
    const initialConfidence = parsedEvent.confidence;
    console.log(
      `  - Initial parse: '${parsedEvent.draftEvent.title}' ending at ${initialEndTime}`,
    );

    const feedback = "actually make it 30 minutes longer";
    const refinedParsedEvent = await intentParser.refineWithAI(
      testUser,
      parsedEvent,
      feedback,
    );
    console.log(`  - Refined with feedback: "${feedback}"`);
    console.log(`    New end time: ${refinedParsedEvent.draftEvent.endTime}`);

    assertExists(refinedParsedEvent, "Refined ParsedEvent should be returned");
    assertEquals(
      refinedParsedEvent.id,
      parsedEvent.id,
      "Refined ParsedEvent ID should remain the same",
    );
    assertNotEquals(
      refinedParsedEvent.draftEvent.endTime,
      initialEndTime,
      "End time should be updated after refinement",
    );

    const initialEndDate = new Date(initialEndTime);
    const refinedEndDate = new Date(refinedParsedEvent.draftEvent.endTime);
    assertEquals(
      refinedEndDate.getTime(),
      initialEndDate.getTime() + 30 * 60 * 1000,
      "End time should be 30 minutes later",
    );
    assertEquals(
      refinedParsedEvent.confidence > initialConfidence,
      true,
      "Confidence should increase slightly after refinement",
    );
    console.log(
      `  - Original Confidence: ${initialConfidence}, New Confidence: ${refinedParsedEvent.confidence}`,
    );

    // Verify the ParsedEvent is still in state
    const alternativesAfterRefine = await intentParser.getAlternatives(
      testUser,
      refinedParsedEvent,
    );
    assertExists(
      alternativesAfterRefine,
      "ParsedEvent should still exist after refinement",
    );
    console.log("  - ParsedEvent still exists in state after refinement.");
    await intentParser.reject(testUser, refinedParsedEvent); // Clean up
  });

  await t.step("5. Accept and Reject workflow completion", async () => {
    console.log("\n--- Accept and Reject Workflow Test ---");
    const utteranceToAccept = "daily standup today at 9am";
    const parsedForAccept = await intentParser.parseWithAI(
      testUser,
      utteranceToAccept,
      testContext,
    );
    assertExists(parsedForAccept, "ParsedEvent for accept should exist");
    console.log(`  - Created ParsedEvent for Acceptance: ${parsedForAccept.id}`);

    const confirmed = await intentParser.accept(
      testUser,
      parsedForAccept,
      parsedForAccept.draftEvent,
    );
    assertExists(confirmed, "Confirmed draft should be returned");
    await assertThrows(
      async () => {
        await intentParser.getAlternatives(testUser, parsedForAccept);
      },
      Error,
      `ParsedEvent with ID ${parsedForAccept.id} not found`,
      "ParsedEvent should be removed after accept",
    );
    console.log("  - ParsedEvent removed after Accept.");

    const utteranceToReject = "cancel all meetings"; // A generic one for AI processing
    const parsedForReject = await intentParser.parseWithAI(
      testUser,
      utteranceToReject,
      testContext,
    );
    assertExists(parsedForReject, "ParsedEvent for reject should exist");
    console.log(`  - Created ParsedEvent for Rejection: ${parsedForReject.id}`);

    await intentParser.reject(testUser, parsedForReject);
    await assertThrows(
      async () => {
        await intentParser.getAlternatives(testUser, parsedForReject);
      },
      Error,
      `ParsedEvent with ID ${parsedForReject.id} not found`,
      "ParsedEvent should be removed after reject",
    );
    console.log("  - ParsedEvent removed after Reject.");
  });

  await t.step("6. Error cases: Invalid inputs, non-existent ParsedEvent IDs", async () => {
    console.log("\n--- Error Cases Test ---");

    // parseWithAI: empty utterance
    await assertThrows(
      async () => {
        await intentParser.parseWithAI(testUser, "", testContext);
      },
      Error,
      "utterance is non-empty requirement failed.",
      "parseWithAI should throw for empty utterance",
    );
    console.log("  - parseWithAI with empty utterance: Correctly threw error.");

    // parseWithAI: missing context
    await assertThrows(
      async () => {
        await intentParser.parseWithAI(testUser, "test", new Map());
      },
      Error,
      "context must include currentDate and timezone",
      "parseWithAI should throw for missing context",
    );
    console.log("  - parseWithAI with missing context: Correctly threw error.");

    // parseManually: empty utterance
    await assertThrows(
      async () => {
        await intentParser.parseManually(testUser, "", testContext);
      },
      Error,
      "utterance is non-empty requirement failed.",
      "parseManually should throw for empty utterance",
    );
    console.log("  - parseManually with empty utterance: Correctly threw error.");

    // Define a dummy non-existent ParsedEvent for error checking
    const nonExistentParsed: ParsedEvent = {
      id: "non-existent-id-123",
      user: testUser,
      utterance: "dummy utterance",
      draftEvent: {
        id: "dummy-draft-456",
        title: "Dummy Event",
        startTime: "2024-01-01T00:00:00Z",
        endTime: "2024-01-01T01:00:00Z",
        participants: new Set(),
        location: "",
        tags: new Set(),
        confidence: 0.5,
      },
      alternatives: [],
      confidence: 0.5,
      context: testContext,
      parsingMethod: "AI",
    };

    // accept with non-existent ParsedEvent ID
    await assertThrows(
      async () => {
        await intentParser.accept(
          testUser,
          nonExistentParsed,
          nonExistentParsed.draftEvent,
        );
      },
      Error,
      `ParsedEvent with ID ${nonExistentParsed.id} not found for user ${testUser.id}`,
      "accept should throw for non-existent ParsedEvent",
    );
    console.log("  - accept with non-existent ParsedEvent: Correctly threw error.");

    // reject with non-existent ParsedEvent ID
    await assertThrows(
      async () => {
        await intentParser.reject(testUser, nonExistentParsed);
      },
      Error,
      `ParsedEvent with ID ${nonExistentParsed.id} not found for user ${testUser.id}`,
      "reject should throw for non-existent ParsedEvent",
    );
    console.log("  - reject with non-existent ParsedEvent: Correctly threw error.");

    // getAlternatives with non-existent ParsedEvent ID
    await assertThrows(
      async () => {
        await intentParser.getAlternatives(testUser, nonExistentParsed);
      },
      Error,
      `ParsedEvent with ID ${nonExistentParsed.id} not found for user ${testUser.id}`,
      "getAlternatives should throw for non-existent ParsedEvent",
    );
    console.log(
      "  - getAlternatives with non-existent ParsedEvent: Correctly threw error.",
    );

    // refineWithAI with non-existent ParsedEvent ID
    await assertThrows(
      async () => {
        await intentParser.refineWithAI(
          testUser,
          nonExistentParsed,
          "make it longer",
        );
      },
      Error,
      `ParsedEvent with ID ${nonExistentParsed.id} not found for user ${testUser.id}`,
      "refineWithAI should throw for non-existent ParsedEvent",
    );
    console.log(
      "  - refineWithAI with non-existent ParsedEvent: Correctly threw error.",
    );

    // refineWithAI with empty feedback
    const parsedForRefineError = await intentParser.parseWithAI(
      testUser,
      "dummy event for refine error",
      testContext,
    );
    await assertThrows(
      async () => {
        await intentParser.refineWithAI(testUser, parsedForRefineError, "");
      },
      Error,
      "userFeedback is non-empty requirement failed.",
      "refineWithAI should throw for empty feedback",
    );
    console.log("  - refineWithAI with empty feedback: Correctly threw error.");
    await intentParser.reject(testUser, parsedForRefineError); // Clean up
  });

  // Trace: Teardown
  await client.close(); // Close the mock database client
});
```
